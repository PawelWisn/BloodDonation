function h() {
  return (h = Object.assign || function(a) {
    var b, d, e;
    for (b = 1; b < arguments.length; b++) {
      d = arguments[b];
      for (e in d) {
        Object.prototype.hasOwnProperty.call(d, e) && (a[e] = d[e]);
      }
    }
    return a;
  }).apply(this, arguments);
}

function k(a, b) {
  return makeOperation(a.kind, a, h({}, a.context, {
    authAttempt: b
  }));
}

function v(a) {
  return "teardown" === a.kind;
}

function w(a) {
  return "teardown" !== a.kind;
}

import { makeOperation, createRequest } from "@urql/core";

import { makeSubject, share, filter, map, merge, mergeMap, empty, fromValue, takeUntil, fromPromise, toPromise, take, onStart } from "wonka";

export function authExchange(a) {
  var b = a.addAuthToOperation, d = a.getAuth, e = a.didAuthError, q = a.willAuthError;
  return function(a) {
    function x(a) {
      return b({
        operation: a,
        authState: f
      });
    }
    var A, r, f, y = a.client, z = a.forward, l = new Map;
    a = makeSubject();
    A = a.source, r = a.next, f = null;
    return function(a) {
      function b(a) {
        a = k(a, !0);
        l.set(a.key, a);
        c || (c = d({
          authState: f,
          mutate: t
        }).then(m).catch(B));
        return c;
      }
      function m(a) {
        f = a;
        c = void 0;
        l.forEach(r);
        l.clear();
      }
      function t(a, b, c) {
        var g = y.createRequestOperation("mutation", createRequest(a, b), c);
        return toPromise(take(1)(filter((function(a) {
          return a.operation.key === g.key;
        }))(onStart((function() {
          return r(g);
        }))(u))));
      }
      function B() {
        return m(null);
      }
      var p, u, c = Promise.resolve().then((function() {
        return d({
          authState: f,
          mutate: t
        });
      })).then(m), n = share(a);
      a = filter(v)(n);
      p = filter(w)(n);
      p = map(x)(merge([ A, mergeMap((function(a) {
        if (!c && q && q({
          operation: a,
          authState: f
        })) {
          return c = b(a), empty;
        }
        if (!c) {
          return fromValue(k(a, !1));
        }
        var g = filter((function(b) {
          return "teardown" === b.kind && b.key === a.key;
        }))(n);
        return takeUntil(g)(map((function() {
          return k(a, !1);
        }))(fromPromise(c)));
      }))(p) ]));
      u = share(z(merge([ p, a ])));
      return filter((function(a) {
        var d = a.error;
        a = a.operation;
        return d && e && e({
          error: d,
          authState: f
        }) && !a.context.authAttempt ? (c = b(a), !1) : !0;
      }))(u);
    };
  };
}
//# sourceMappingURL=urql-exchange-auth.mjs.map
